{
  "name": "Flamyngo",
  "tagline": "Flask frontend for MongoDB",
  "body": "# Flamyngo\r\n\r\nFlamyngo is a customizable Flask frontend for MongoDB.\r\n\r\nAt the most basic level, the aim is to delegate most settings to a YAML\r\nconfiguration file, which then allows the  underlying code to be reused for\r\nany conceivable collection.\r\n\r\n# Usage\r\n\r\nClone or download the code. Install it if you wish.\r\n\r\nIn the root directory, run:\r\n\r\n```bash\r\npython scripts/flm --config <path/to/config.yaml>\r\n```\r\n\r\nIf `--config` is not provided, it defaults to `$HOME/.flamyngo.yaml`.\r\n\r\n# Configuration\r\n\r\nA sample commented configuration yaml file is given below.\r\n\r\n```yaml\r\n# MongoDB settings\r\ndb:\r\n  host: mongo.host.com\r\n  port: 27017\r\n  username: user\r\n  password: password\r\n  database: mydb\r\n\r\n# List of collection settings. Note that more than one collection is supported,\r\n# though only one collection can be queried at any one time.\r\ncollections:\r\n  -\r\n    name: mycoll\r\n\r\n    # These set the special queries as an ordered list of [<key>, <regex string>, <type>].\r\n    # If the query string satisfies any of the regex, the Mongo query is set as\r\n    # {<key>: type(<search_string>)}. This allows for much more friendly setups for common\r\n    # queries that do not require a user to type in verbose Mongo criteria. Each\r\n    # regex should be uniquely identifying.\r\n    # Types can be any kind of callable function that takes in a string and return\r\n    # a value without other arguments. E.g., int, str, float, etc. You can support\r\n    # more powerful conversions by writing your own processing function, e.g., \r\n    # mymodule.convert_degress_to_radians. \r\n    # If none of the regex works, the criteria is interpreted as a Mongo-like dict query.\r\n    query:\r\n      - [last_name, '^[A-Za-z]+$', str]\r\n      - [phone_number, '^[0-9]+$', int]\r\n\r\n    # A default list of projection key, processing function to display as a table. \r\n    # Again, processing function can be any callable, and you can define your own.\r\n    # For example, you can take in a float and render it as a fixed decimal.\r\n    # The alias is optional. If provided, the alias will be used as the column name.\r\n    summary:\r\n      - [_id, str]\r\n      - [first_name, str]\r\n      - [last_name, str]\r\n      - [phone_number, str]\r\n\r\n    # Aliases for various fields. These are used to display short names in the summary\r\n    # table. You can also directly perform queries using the short names instead of\r\n    # using the long names.\r\n    aliases:\r\n        phone_number: number\r\n\r\n    # The following defines unique identifiers for each doc. This allows each\r\n    # specific doc to be queried and displayed using this key. If this key is\r\n    # present in the default list of projections, a link will be created to each\r\n    # unique document.\r\n    unique_key: _id\r\n    unique_key_type: bson.objectid.ObjectId\r\n\r\n# Basic auth can be set up by specifying user and password below. If these are not\r\n# set, then no authentication. Note that this is not the most secure. It is merely\r\n# used for a basic setup. For high security, look into proper implementations.\r\nAUTH_USER: Iam\r\nAUTH_PASSWD: Pink\r\n```\r\n\r\n# URLs\r\n\r\nAssuming that you are running on local host at port 5000, the initial\r\nlanding page will be at http://localhost:5000.\r\n\r\nPages for individual docs following the format \r\nhttp://localhost:5000/[collection_name]/doc/[unique_id].\r\n\r\nA RESTful link for downloading individual docs as a json response is \r\ngiven as http://localhost:5000/[collection_name]/doc/[unique_id]/json.\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}